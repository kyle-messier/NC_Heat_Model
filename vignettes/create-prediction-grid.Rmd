---
title: "create-prediction-grid"
output:
  pdf_document: default
  html_document: default
date: "2023-07-20"
---

Libraries

```{r, message=F}
#library(raster)   # -- old
#library(sp)       # -- old
#library(rgdal)    # -- deprecated in 10/2023
#library(rgeos)    # -- deprecated in 10/2023
#library(maptools) # -- deprecated in 10/2023
library(terra)
library(sf)

library(ggplot2)
library(ggspatial)
library(tidyterra)
library(rgeos)
library(data.table) # -- for large flat datasets
```

### In this script...

#### 1) Create empty grid

1.  Open NC borders and 30m-imperviousness data over NC

2.  Compute imperviousness mean over 5km-resolution grid

3.  Create an urban mask defined as 5kmx5km grid cells with imperviousness \>5%

4.  Create a grid with 1kmx1km cells above rural areas and 200mx200m cells above urban ones

#### 2) Add covariates

-   Land cover and urban indicators: imperviousness, building footprint, building height, tree canopy cover

-   Digital Elevation Model (DEM)

-   Meteorological covariates

#### 3) Save prediction grid with space-time covariates in a datatable

## Empty grid creation

### NC borders

```{r}
nc.borders <- vect("../input/NC_county_boundary/North_Carolina_State_and_County_Boundary_Polygons.shp")
```

Change nc.borders units (us feet to meter)

```{r}
crs.meters <- "+proj=lcc +lat_0=33.75 +lon_0=-79 +lat_1=36.1666666666667 +lat_2=34.3333333333333 +x_0=609601.219202439 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
nc.borders <- project(nc.borders, crs.meters)
```

### 5km-resolution imperviousness grid

Open and map imperviousness 30m-resolution data across NC

```{r}
imp <- rast("../input/NC_imperviousness_2019.tif")
imp <- project(imp, crs.meters)

imp.plot <- ifel(imp==0, NA, imp)
ggplot() +
  geom_spatraster(data = imp.plot) +
  geom_sf(data = st_as_sf(nc.borders), aes(geometry=geometry), 
               colour = "grey", linewidth=.3, fill = NA) +
  scale_fill_whitebox_c(
    palette = "muted",
    labels = scales::label_number(suffix = "%"),
    n.breaks = 12,
    guide = guide_legend(reverse = TRUE),
    na.value=NA
  ) +
  labs(
    fill = "",
    title = "Prediction grid"
  ) +
  annotation_scale(
    location="bl", pad_x = unit(1, "cm"), 
		pad_y = unit(1, "cm"), 
		height = unit(0.30, "cm"), 
		text_cex = 1
	) +
	annotation_north_arrow(
	  location = "br", 
	  which_north = "true", 
		pad_x = unit(0.2, "cm"), 
		pad_y = unit(0.2, "cm")
	) +
	theme(
			axis.text = element_text(size=12, family="serif"),
			plot.caption = element_text(size=10, family="serif"),
			legend.text = element_text(size=12, family="serif"),
			legend.title = element_text(size=12, family="serif"),
			panel.background = element_rect(fill = "white"),
			panel.grid.major=element_line(colour="grey")
		)
```

Create 5km and 10km-resolution raster in NC shapefile

```{r}
grid.10km <- rast(ext(nc.borders), resolution = c(10000, 10000), crs = crs.meters)
grid.10km <- extend(grid.10km, c(1,1))
grid.10km <- as.polygons(grid.10km)
grid.10km <- terra::intersect(grid.10km, nc.borders)
plot(grid.10km)

grid.5km <- rast(ext(nc.borders), resolution = c(5000,5000), crs = crs.meters)
grid.5km <- extend(grid.5km, c(1,1))
grid.5km <- as.polygons(grid.5km)
grid.5km <- terra::intersect(grid.5km, nc.borders)
plot(grid.5km)
```

Compute and save 5kmx5km imperviousness file (each 5kmx5km cell is the mean of 30mx30m info)

```{r, eval=F}
imp.mean <- zonal(imp, grid.5km, fun='mean', as.raster=T)
writeRaster(imp.mean, filename="../input/NC_imperviousness_2019_5kmx5km.tif", overwrite=T)
```

Open and map the 5kmx5km imperviousness file

```{r}
imp.mean <- rast("../input/NC_imperviousness_2019_5kmx5km.tif")
ggplot() +
  geom_spatraster(data = imp.mean) +
  geom_sf(data = st_as_sf(nc.borders), aes(geometry=geometry), 
               colour = "white", linewidth=.3, fill = NA) +
  scale_fill_whitebox_c(
    palette = "muted",
    labels = scales::label_number(suffix = "%"),
    n.breaks = 12,
    guide = guide_legend(reverse = TRUE)
  ) +
  labs(
    fill = "",
    title = "North Carolina imperviousness rate"
  ) +
  annotation_scale(
    location="bl", pad_x = unit(1, "cm"), 
		pad_y = unit(1, "cm"), 
		height = unit(0.30, "cm"), 
		text_cex = 1
	) +
	annotation_north_arrow(
	  location = "br", 
	  which_north = "true", 
		pad_x = unit(0.2, "cm"), 
		pad_y = unit(0.2, "cm")
	) +
	theme(
			axis.text = element_text(size=12, family="serif"),
			plot.caption = element_text(size=10, family="serif"),
			legend.text = element_text(size=12, family="serif"),
			legend.title = element_text(size=12, family="serif"),
			panel.background = element_rect(fill = "white"),
			panel.grid.major=element_line(colour="grey")
		)
```

### Create urban and rural masks

-   Urban pixels: 5kmx5km imperviousness \> 5%

-   Urban pixels: 5kmx5km imperviousness \<= 5%

```{r}
urb.mask <- ifel(imp.mean>5, 1, NA)
rur.mask <- ifel(imp.mean<=5, 1,NA)
ggplot() +
  geom_spatraster(data = urb.mask) +
  geom_sf(data = st_as_sf(nc.borders), aes(geometry=geometry), 
               colour = "grey", linewidth=.3, fill = NA) +
  scale_fill_whitebox_c(
    palette = "deep",
    labels = scales::label_number(suffix = ""),
    na.value=NA
  ) +
  labs(
    fill = "",
    title = "North Carolina urban mask"
  ) +
  annotation_scale(
    location="bl", pad_x = unit(1, "cm"), 
		pad_y = unit(1, "cm"), 
		height = unit(0.30, "cm"), 
		text_cex = 1
	) +
	annotation_north_arrow(
	  location = "br", 
	  which_north = "true", 
		pad_x = unit(0.2, "cm"), 
		pad_y = unit(0.2, "cm")
	) +
	theme(
			axis.text = element_text(size=12, family="serif"),
			plot.caption = element_text(size=10, family="serif"),
			legend.position = "none",
			panel.background = element_rect(fill = "white"),
			panel.grid.major=element_line(colour="grey")
		)
```

Urban grid (200m-resolution)

```{r}
urb.pol <- as.polygons(urb.mask)
urb.rast <- rast(urb.pol, resolution = c(200, 200), crs = crs.meters)
urb.grid <- as.polygons(urb.rast)
urb.grid <- terra::intersect(urb.grid, urb.pol)
```

Rural grid (1km-resolution)

```{r}
rur.pol <- as.polygons(rur.mask)
rur.rast <- rast(rur.pol, resolution = c(1000, 1000), crs = crs.meters)
rur.grid <- as.polygons(rur.rast)
rur.grid <- terra::intersect(rur.grid, rur.pol)
```

### Map and save empty prediction grid

```{r}
m <- ggplot() +
  geom_spatvector(data = urb.grid, color='orange', size=.1) +
  geom_spatvector(data = rur.grid, color='green', size=.1) +
  geom_sf(data = st_as_sf(nc.borders), aes(geometry=geometry), 
               colour = "grey", linewidth=.3, fill = NA) +
  labs(
    fill = "",
    title = "Prediction grid"
  ) +
  annotation_scale(
    location="bl", pad_x = unit(1, "cm"), 
		pad_y = unit(1, "cm"), 
		height = unit(0.30, "cm"), 
		text_cex = 1
	) +
	annotation_north_arrow(
	  location = "br", 
	  which_north = "true", 
		pad_x = unit(0.2, "cm"), 
		pad_y = unit(0.2, "cm")
	) +
	theme(
			axis.text = element_text(size=12, family="serif"),
			plot.caption = element_text(size=10, family="serif"),
			legend.text = element_text(size=12, family="serif"),
			legend.title = element_text(size=12, family="serif"),
			panel.background = element_rect(fill = "white"),
			panel.grid.major=element_line(colour="grey")
		)
m
```

Save urban and rural grid (squared polygons) and save all prediction grid as a unique dataframe (centroids of raster's polygons, coordinates in wgs84)

```{r}
urb.grid.df <- centroids(urb.grid, inside=T)
rur.grid.df <- centroids(rur.grid, inside=T)
urb.grid.df$geo <- 'urb'
rur.grid.df$geo <- 'rur'
grid.points <- rbind(urb.grid.df, rur.grid.df)
grid.points <- project(grid.points, crs.meters)
# -- keep only the geo covariate
grid.points <- grid.points %>% select(geo)
writeVector(grid.points, "../input/prediction_grid_points_urb_rur_empty.shp", overwrite=T)
```

## Spatial covariates addition

Interesting: with the terra::extract function, possibility to chose method='bilinear' to return a value interpolated from the values of the four nearest raster cells.

```{r}
grid.points <- vect("../input/prediction_grid_points_urb_rur_empty.shp")
```

Create entent for RTP area if we want to plot a zoom

```{r}
lat <- c(35.6, 36.11, 36.11, 35.6)
lon <- c(-79.19, -79.10, -78.39, -78.39)
ext.rtp <- vect(cbind(lon, lat), type="points", crs="+proj=longlat +datum=WGS84")
ext.rtp <- project(ext.rtp, crs(nc.borders))
ext(ext.rtp)
```

#### Open covariates projected on crs.meters

```{r}
imp <- rast("../input/NC_imperviousness_2019_crs-meters.tif")
tcc <-  rast("../input/NC_tree-canopy-cover_2021_crs-meters.tif")
build.fp <-  rast("../input/NC_building-footprints/NorthCarolina_sum_crs-meters.tif")
build.h <-  vect("../input/NC_building-height-by-block/NC_building-heights-by-block_crs-meters.shp")
dem <- rast("../input/NC-DEM_crs-meters.tif")
```

#### Extract at each grid point

```{r}
grid.spatcov <- grid.points
grid.spatcov <- terra::extract(imp, grid.points, bind=T) 
grid.spatcov <- terra::extract(tcc, grid.spatcov, fun=function(x) mean(x, na.rm=T), method='bilinear', bind=T)
grid.spatcov <- terra::extract(build.fp, grid.spatcov, fun='mean', method='bilinear', bind=T)
grid.spatcov <- terra::extract(dem, grid.spatcov, bind=T) 

# -- build.h is a vector and not a raster, bind=T doesn't work...
grid0 <- terra::extract(build.h[,c("Height_cat")], grid.points) 
grid.spatcov$build.h <- grid0$Height_cat
```

#### Rename covariates

```{r}
grid.spatcov <- grid.spatcov %>% rename(
  imp = 'NC_imperviousness_2019',
  tcc = 'NC_tree-canopy-cover_2021',
  build.fp = 'NorthCarolina_sum', 
  dem = 'Layer_1'
)

summary(grid.spatcov)
```

## Temporal covariates addition

TN with WMO standards

```{r}
v <- data.frame(cbind(lon=geom(grid.points)[,'x'], lat=geom(grid.points)[,'y']))
grid.timecov <- vect(v, geom=c('lon', 'lat'))
grid.timecov$geom <- geom(grid.timecov)[, 'geom']
era5.jja.vector.TNwmo <- rast('../input/era5_daily_reanalysis_20220601_20220831_TNwmo.tif')
era5.jja.vector.TN7am <- rast('../input/era5_daily_reanalysis_20220601_20220831_TN7am.tif')
era5.jja.vector.TN12am <- rast('../input/era5_daily_reanalysis_20220601_20220831_TN12am.tif')

era5.jja.vector.TNwmo <- project(era5.jja.vector.TNwmo, crs.meters)
era5.jja.vector.TN7am <- project(era5.jja.vector.TN7am, crs.meters)
era5.jja.vector.TN12am <- project(era5.jja.vector.TN12am, crs.meters)

grid.timecov.TNwmo <- terra::extract(era5.jja.vector.TNwmo, grid.timecov, bind=T) 
grid.timecov.TN7am <- terra::extract(era5.jja.vector.TN7am, grid.timecov, bind=T) 
grid.timecov.TN12am <- terra::extract(era5.jja.vector.TN12am, grid.timecov, bind=T) 

era5.jja.vector.TXwmo <- rast('../input/era5_daily_reanalysis_20220601_20220831_TXwmo.tif')
era5.jja.vector.TX7am <- rast('../input/era5_daily_reanalysis_20220601_20220831_TX7am.tif')
era5.jja.vector.TX12am <- rast('../input/era5_daily_reanalysis_20220601_20220831_TX12am.tif')

era5.jja.vector.TXwmo <- project(era5.jja.vector.TXwmo, crs.meters)
era5.jja.vector.TX7am <- project(era5.jja.vector.TX7am, crs.meters)
era5.jja.vector.TX12am <- project(era5.jja.vector.TX12am, crs.meters)

grid.timecov.TXwmo <- terra::extract(era5.jja.vector.TXwmo, grid.timecov, bind=T) 
grid.timecov.TX7am <- terra::extract(era5.jja.vector.TX7am, grid.timecov, bind=T) 
grid.timecov.TX12am <- terra::extract(era5.jja.vector.TX12am, grid.timecov, bind=T) 

df.grid.timecov.TNwmo <- melt(setDT(as.data.frame(grid.timecov.TNwmo)), id.vars = 'geom', variable.name = 'DATE', value.name='TNwmo')
df.grid.timecov.TN7am <- melt(setDT(as.data.frame(grid.timecov.TN7am)), id.vars = 'geom', variable.name = 'DATE', value.name='TN7am')
df.grid.timecov.TN12am <- melt(setDT(as.data.frame(grid.timecov.TN12am)), id.vars = 'geom', variable.name = 'DATE', value.name='TN12am')
df.grid.timecov.TXwmo <- melt(setDT(as.data.frame(grid.timecov.TXwmo)), id.vars = 'geom', variable.name = 'DATE', value.name='TXwmo')
df.grid.timecov.TX7am <- melt(setDT(as.data.frame(grid.timecov.TX7am)), id.vars = 'geom', variable.name = 'DATE', value.name='TX7am')
df.grid.timecov.TX12am <- melt(setDT(as.data.frame(grid.timecov.TX12am)), id.vars = 'geom', variable.name = 'DATE', value.name='TX12am')

dt.time <- merge(df.grid.timecov.TNwmo, df.grid.timecov.TN7am, by=c('geom', 'DATE'))
dt.time <- merge(dt.time, df.grid.timecov.TN12am, by=c('geom', 'DATE'))
dt.time <- merge(dt.time, df.grid.timecov.TXwmo, by=c('geom', 'DATE'))
dt.time <- merge(dt.time, df.grid.timecov.TX7am, by=c('geom', 'DATE'))
dt.time <- merge(dt.time, df.grid.timecov.TX12am, by=c('geom', 'DATE'))
```

## Merge spatial and temporal covariates

Reproject grid points, add lat, lon, geom and transform to data.table

```{r}
crs.wgs84 <- '+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'
grid.spatcov <- project(grid.spatcov, crs.wgs84)
grid.spatcov$geom <- geom(grid.spatcov)[, 'geom']
grid.spatcov$lon <- geom(grid.spatcov)[, 'x']
grid.spatcov$lat <- geom(grid.spatcov)[, 'y']
dt.spat <- setDT(as.data.frame(grid.spatcov))
```

```{r}
grid.spattimecov <- merge(dt.spat, dt.time, by=c('geom'))
```

The prediction grid will be stored as a dataframe (or datatable) with columns:

-   lat, lon, date

-   TN, TX (varies in space and time)

-   dem, imp, tcc, build.fp, build.h (varies in space)

It will have 56.794.820 rows (617335 pixels and 92 days) and 10 columns.

```{r}
fwrite(grid.spattimecov, '../input/prediction_grid_points_urb_rur_space_time_covariates_jja2022.csv')
```

------------------------------------------------------------------------

### Session info

```{r}
sessionInfo()
```